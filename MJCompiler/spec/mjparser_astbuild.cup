

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   boolean errorDetected;
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected=true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, L_BRACE, R_BRACE, SEMI, COMMA, EQUALS, CONST, L_INDEXER, R_INDEXER;
terminal L_PAREN, R_PAREN, READ, PRINT;
terminal INCREMENT, DECREMENT, DOT, NEW, MINUS, PLUS, MULTIPLY, DIVIDE, MODULATE, RETURN, AT, REALAT, TAR, ADDEQUALS, SUBEQUALS, MULEQUALS, DIVEQUALS, MODEQUALS, DOLAREQUALS;

terminal String IDENT;
terminal String VOID;
terminal Integer NUMBER;
terminal Boolean BOOL;
terminal Character CHAR;
nonterminal ProgramElementsList ProgramElementsList;
nonterminal ProgramElement ProgramElement;
nonterminal VarDecl VarDecl;
nonterminal VarsElementsList VarsElementsList;
nonterminal NumbersListOptional NumbersListOptional;
nonterminal NumbersList NumbersList;
nonterminal AddOp AddOp;
nonterminal MulOp MulOp;
nonterminal Tar Tar;
nonterminal PreArrIdxDummy PreArrIdxDummy;
nonterminal AssignOp AssignOp;
nonterminal AddOpLeft AddOpLeft;
nonterminal AddOpRight AddOpRight;
nonterminal MulOpLeft MulOpLeft;
nonterminal MulOpRight MulOpRight;
nonterminal FormParams FormParams;
nonterminal FormParamsList FormParamsList;
nonterminal ArrayDecl ArrayDecl;
nonterminal ActualParams ActualParams;
nonterminal ActualParamsList ActualParamsList;
nonterminal Empty Empty;


nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, ConstDecl, ConstList, OneVar;
nonterminal rs.etf.pp1.symboltable.concepts.Obj VarsList, MethodsList, MethodDecl, DesignatorStatement, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Obj StatementsList, Statement, GlobalVariable, GlobalVarDeclList, GlobalVarDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Struct OneConst, Type, VoidType, Term, Factor, FactorAt, Expr, Expression, NewArrayType, Assignment, TermTar;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodName, FormParam, MethCall;

Program ::= (Program) PROG ProgName:p ProgramElementsList:P1 L_BRACE MethodsList:M2 R_BRACE {: RESULT=new Program(p, P1, M2); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:programName {: RESULT=new ProgName(programName); RESULT.setLine(programNameleft); :};

ProgramElementsList ::= (ProgramElementList) ProgramElementsList:P1 ProgramElement:P2 {: RESULT=new ProgramElementList(P1, P2); RESULT.setLine(P1left); :} 
						|
						(NoProgramElementsList) {: RESULT=new NoProgramElementsList(); :}/* epsilon */
						;
												
ProgramElement ::=(ProgramElementConstDecl)ConstDecl:C1 {: RESULT=new ProgramElementConstDecl(C1); RESULT.setLine(C1left); :} 
				|
				(ProgramElementVarDecl) GlobalVarDecl:G1 {: RESULT=new ProgramElementVarDecl(G1); RESULT.setLine(G1left); :};
												
ConstDecl ::= (ConstDecl) CONST Type:t ConstList:c SEMI {: RESULT=new ConstDecl(t, c); RESULT.setLine(tleft); :} ;

ConstList ::= (ListConst) ConstList:C1 COMMA IDENT:constName EQUALS OneConst:ConstObject {: RESULT=new ListConst(C1, constName, ConstObject); RESULT.setLine(C1left); :}
				|
			  (SingleConst) IDENT:constName EQUALS OneConst:currentConstObject {: RESULT=new SingleConst(constName, currentConstObject); RESULT.setLine(constNameleft); :}; 

OneConst ::=    (Const) NUMBER:value {: RESULT=new Const(value); RESULT.setLine(valueleft); :}
				|
			 	(Char) CHAR:value {: RESULT=new Char(value); RESULT.setLine(valueleft); :}
				|
			 	(Bool) BOOL:value {: RESULT=new Bool(value); RESULT.setLine(valueleft); :}
				;
				
GlobalVarDecl ::=  (GlobalVarDecl) Type:type GlobalVarDeclList:gl SEMI {: RESULT=new GlobalVarDecl(type, gl); RESULT.setLine(typeleft); :};

GlobalVarDeclList ::= (GlobalVarDeclList_List) GlobalVarDeclList:t COMMA GlobalVariable:vx {: RESULT=new GlobalVarDeclList_List(t, vx); RESULT.setLine(tleft); :}
                            |
                      (GlobalVarDeclList_Item) GlobalVariable:ver {: RESULT=new GlobalVarDeclList_Item(ver); RESULT.setLine(verleft); :};
                          
                         
GlobalVariable ::= (OneGlobalVarDecl) OneVar:one {: RESULT=new OneGlobalVarDecl(one); RESULT.setLine(oneleft); :}
			  		|
				(GlobalVarError) error:e
				{: parser.report_error("Oporavak od greske u definiciji globalne promenljive na liniji " + eleft, null); :} {: RESULT=new GlobalVarError(); :}
			     ;
			
OneVar ::= 	(Var) IDENT:varName {: RESULT=new Var(varName); RESULT.setLine(varNameleft); :}
 			|
 			(OneVarArray)IDENT:varName L_INDEXER R_INDEXER {: RESULT=new OneVarArray(varName); RESULT.setLine(varNameleft); :};
 			
VarDecl ::=	(TypeVarsElementsList) Type:varType VarsElementsList:list SEMI {: RESULT=new TypeVarsElementsList(varType, list); RESULT.setLine(varTypeleft); :}		
			|
			(ErrorVarDecl) Type:T1 error SEMI:e {: RESULT=new ErrorVarDecl(T1); RESULT.setLine(T1left); :}
			;
			
			

VarsElementsList ::=  (ListVar) VarsElementsList:l COMMA OneVar:one {: RESULT=new ListVar(l, one); RESULT.setLine(lleft); :}
 						|
 						error COMMA OneVar:e
 						{: parser.report_error("Oporavak od greske u definiciji globalne promenljive [prazno]", null); :} {: RESULT=new VarsElementsListDerived1(e); RESULT.setLine(eleft); :}
 						|
 						(SignleVar) OneVar:one {: RESULT=new SignleVar(one); RESULT.setLine(oneleft); :}
 						|
 						error OneVar:O1 {: RESULT=new VarsElementsListDerived2(O1); RESULT.setLine(O1left); :};
 
 			
VarsList ::= (VarListDeclarations) VarsList:vl VarDecl:vd {: RESULT=new VarListDeclarations(vl, vd); RESULT.setLine(vlleft); :}
					|
					(NoVarListDeclarations) {: RESULT=new NoVarListDeclarations(); :}/* epsilon */
					;
					
Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};

MethodsList ::= (MethodDeclarations) MethodsList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :} 
				|
				(NoMethodDeclarations) {: RESULT=new NoMethodDeclarations(); :}/* epsilon */
				; 
MethodDecl ::= (MethodDecl) VoidType:vtt MethodName:n L_PAREN FormParams:fParams R_PAREN 
				VarsList:vlm L_BRACE:l
				StatementsList:st R_BRACE:r {: RESULT=new MethodDecl(vtt, n, fParams, vlm, st); RESULT.setLine(vttleft); :}
				;
MethodName ::= (MethodName) IDENT:methodName {: RESULT=new MethodName(methodName); RESULT.setLine(methodNameleft); :};

VoidType ::= (TypeMethod) Type:t {: RESULT=new TypeMethod(t); RESULT.setLine(tleft); :}
			|
			(VoidMethod) VOID:value {: RESULT=new VoidMethod(value); RESULT.setLine(valueleft); :};
			

FormParams ::= (FormParameters)FormParamsList:fpl {: RESULT=new FormParameters(fpl); RESULT.setLine(fplleft); :}
			   |
			   (NoFormParams) {: RESULT=new NoFormParams(); :}/*  epsilon */;

FormParamsList ::= (FormParametersList) FormParamsList:fpList COMMA FormParam:fpAfterComma {: RESULT=new FormParametersList(fpList, fpAfterComma); RESULT.setLine(fpListleft); :} 
				   |
				   (OneParam) FormParam:fpOne {: RESULT=new OneParam(fpOne); RESULT.setLine(fpOneleft); :}
				   ;
				   
FormParam ::= (FormParamIdent) Type:fpt IDENT:fpName {: RESULT=new FormParamIdent(fpt, fpName); RESULT.setLine(fptleft); :} 
			  |
			  (ArrayFormParam) Type:fptArray IDENT:fpNameArray L_INDEXER R_INDEXER {: RESULT=new ArrayFormParam(fptArray, fpNameArray); RESULT.setLine(fptArrayleft); :}
			  ;

StatementsList ::= (ListStatements) StatementsList:st Statement:t {: RESULT=new ListStatements(st, t); RESULT.setLine(stleft); :}
					| {: RESULT=new StatementsListDerived1(); :}
					/* epsilon */
					;
					
Statement ::= 	(DesignatorStmt) DesignatorStatement:d {: RESULT=new DesignatorStmt(d); RESULT.setLine(dleft); :}
				|
				(ReadStmt) READ L_PAREN Designator:des R_PAREN SEMI {: RESULT=new ReadStmt(des); RESULT.setLine(desleft); :}
				|
				(PrintStmt) PRINT L_PAREN Expr:expr NumbersListOptional:N1 R_PAREN SEMI {: RESULT=new PrintStmt(expr, N1); RESULT.setLine(exprleft); :}
				|
				(ReturnStmEmpty) RETURN:retEmpty SEMI {: RESULT=new ReturnStmEmpty(); :}
				|
				(ReturnStmWithValue) RETURN Expr:retExp SEMI {: RESULT=new ReturnStmWithValue(retExp); RESULT.setLine(retExpleft); :}
				;		 

				
NumbersListOptional ::= (NumbersListExists) COMMA NUMBER:value {: RESULT=new NumbersListExists(value); RESULT.setLine(valueleft); :}
				| {: RESULT=new NumbersListOptionalDerived1(); :}
				/* epsilon*/
				;
				
DesignatorStatement ::= (AssignmentDesignator) Designator:D1 Assignment:A2 {: RESULT=new AssignmentDesignator(D1, A2); RESULT.setLine(D1left); :}
						|
						(Increment) Designator:des INCREMENT SEMI {: RESULT=new Increment(des); RESULT.setLine(desleft); :}
						|
						(Decrement) Designator:des DECREMENT SEMI {: RESULT=new Decrement(des); RESULT.setLine(desleft); :}
						|
						(DesStmMethodCall) MethCall:M1 SEMI {: RESULT=new DesStmMethodCall(M1); RESULT.setLine(M1left); :}
						;
						
MethCall ::= (MethodCall) Designator:methName L_PAREN ActualParams:actParams R_PAREN {: RESULT=new MethodCall(methName, actParams); RESULT.setLine(methNameleft); :} ;

ActualParams ::= (ActualParameters) ActualParamsList:apl {: RESULT=new ActualParameters(apl); RESULT.setLine(aplleft); :}
				 |
				 (NoActualParams) {: RESULT=new NoActualParams(); :} /* epsilon*/
				 ;
				 
ActualParamsList ::= (ActualParametersList) ActualParamsList:apList COMMA Expr:E1 {: RESULT=new ActualParametersList(apList, E1); RESULT.setLine(apListleft); :}
				 	 |
				 	 (OneActualParam) Expr:oneAps {: RESULT=new OneActualParam(oneAps); RESULT.setLine(oneApsleft); :}
				 	 ;
				 	 
						
Assignment ::= (Assignment_Expr) AssignOp:A1 Expr:E2 SEMI {: RESULT=new Assignment_Expr(A1, E2); RESULT.setLine(A1left); :}
               |
               (Assignment_Error) AssignOp:A1 error:e SEMI
               {: parser.report_error("Oporavak od greske u konstrukciji iskaza dodele na liniji " + eleft, null); :} {: RESULT=new Assignment_Error(A1); RESULT.setLine(A1left); :}
               ;				
Designator ::=  (DesignatorIdent) IDENT:identifier {: RESULT=new DesignatorIdent(identifier); RESULT.setLine(identifierleft); :}
				|
				(DesignatorArray) Designator:des L_INDEXER PreArrIdxDummy:pr Expr:exp R_INDEXER {: RESULT=new DesignatorArray(des, pr, exp); RESULT.setLine(desleft); :}
				|
				(DesignatorError) Designator:D1 L_INDEXER error R_INDEXER {: RESULT=new DesignatorError(D1); RESULT.setLine(D1left); :}
				;
		
			
PreArrIdxDummy ::= (PreArrIdxDummy) {: RESULT=new PreArrIdxDummy(); :} /* epsilon */ ;

Expr ::= 	(Expr) Empty:E1 Expression:E2 {: RESULT=new Expr(E1, E2); RESULT.setLine(E1left); :};

Empty ::= (Empty) {: RESULT=new Empty(); :};
				
Expression ::= 	(TermAddOp) Expression:E1 AddOp:A2 TermTar:T3 {: RESULT=new TermAddOp(E1, A2, T3); RESULT.setLine(E1left); :} 
				|
				(SingleTermTarMinus) MINUS TermTar:T1 {: RESULT=new SingleTermTarMinus(T1); RESULT.setLine(T1left); :}
				|
				(SingleTermTar) TermTar:T1 {: RESULT=new SingleTermTar(T1); RESULT.setLine(T1left); :}
				;

TermTar ::= (TermTarOp) TermTar:T1 Tar:T2 Term:T3 {: RESULT=new TermTarOp(T1, T2, T3); RESULT.setLine(T1left); :} 
				|
				(SingleTerm) Term:T1 {: RESULT=new SingleTerm(T1); RESULT.setLine(T1left); :}
				;

Term ::= (FactorMulOp) Term:T1 MulOp:M2 FactorAt:F3 {: RESULT=new FactorMulOp(T1, M2, F3); RESULT.setLine(T1left); :}
				|
				(SingleAtFactor) FactorAt:F1 {: RESULT=new SingleAtFactor(F1); RESULT.setLine(F1left); :}
				;
			
FactorAt ::= (FactorAtOp) FactorAt:F1 AT {: RESULT=new FactorAtOp(F1); RESULT.setLine(F1left); :}
			|
			(SingleFactor) Factor:F1 {: RESULT=new SingleFactor(F1); RESULT.setLine(F1left); :}
			;
										
Factor ::=  (ConstFactor) OneConst:constant {: RESULT=new ConstFactor(constant); RESULT.setLine(constantleft); :}
			|
			(NewFactor) NEW Type:typeObject NewArrayType:arrayObject {: RESULT=new NewFactor(typeObject, arrayObject); RESULT.setLine(typeObjectleft); :}
			|
			(ParenFactor) L_PAREN Expr:E1 R_PAREN {: RESULT=new ParenFactor(E1); RESULT.setLine(E1left); :} 
			|
			(DesigFactor) Designator:D1 {: RESULT=new DesigFactor(D1); RESULT.setLine(D1left); :}
			|
			(FactorMethCall) MethCall:fmc {: RESULT=new FactorMethCall(fmc); RESULT.setLine(fmcleft); :}
			|
			(FactorArray) Designator:D1 REALAT NUMBER:value {: RESULT=new FactorArray(D1, value); RESULT.setLine(D1left); :}
			;
			
NewArrayType ::= (NewArray) L_INDEXER Expr:exp R_INDEXER {: RESULT=new NewArray(exp); RESULT.setLine(expleft); :}
					|
				 (NoNewArray) {: RESULT=new NoNewArray(); :} /* epsilon */
					; 

AssignOp ::= (AssignOp_Equals) EQUALS {: RESULT=new AssignOp_Equals(); :}
		  |	
		  (AssignOp_AddOpRight) AddOpRight:A1 {: RESULT=new AssignOp_AddOpRight(A1); RESULT.setLine(A1left); :}
		  |
		  (AssignOp_MulOpRight) MulOpRight:M1 {: RESULT=new AssignOp_MulOpRight(M1); RESULT.setLine(M1left); :};

AddOp ::= (AddOp_AddOpRight) AddOpRight:A1 {: RESULT=new AddOp_AddOpRight(A1); RESULT.setLine(A1left); :}
		  |
		  (AddOp_AddOpLeft) AddOpLeft:A1 {: RESULT=new AddOp_AddOpLeft(A1); RESULT.setLine(A1left); :};
		 
MulOp ::= (MulOp_MulOpRight) MulOpRight:M1 {: RESULT=new MulOp_MulOpRight(M1); RESULT.setLine(M1left); :}
		  |
		  (MulOp_MulOpLeft) MulOpLeft:M1 {: RESULT=new MulOp_MulOpLeft(M1); RESULT.setLine(M1left); :};		  			

AddOpLeft ::= (AddOp_Plus) PLUS {: RESULT=new AddOp_Plus(); :}
		  |
		  (AddOp_Minus) MINUS {: RESULT=new AddOp_Minus(); :};	
					
MulOpLeft ::= (MulOp_Multiply) MULTIPLY {: RESULT=new MulOp_Multiply(); :}
		  |
		  (MulOp_Divide) DIVIDE {: RESULT=new MulOp_Divide(); :}
		  |
		  (MulOp_Modulate) MODULATE {: RESULT=new MulOp_Modulate(); :};

Tar ::= (Tar) TAR {: RESULT=new Tar(); :};
		  
AddOpRight ::= (AddOp_PlusEqual) ADDEQUALS {: RESULT=new AddOp_PlusEqual(); :}
		  |
		  (AddOp_MinusEqual) SUBEQUALS {: RESULT=new AddOp_MinusEqual(); :}
		  |
		  (AddOp_DolarEqual) DOLAREQUALS {: RESULT=new AddOp_DolarEqual(); :}
		  ;	
					
MulOpRight ::= (MulOp_MultiplyEqual) MULEQUALS {: RESULT=new MulOp_MultiplyEqual(); :}
		  |
		  (MulOp_DivideEqual) DIVEQUALS {: RESULT=new MulOp_DivideEqual(); :}
		  |
		  (MulOp_ModulateEqual) MODEQUALS {: RESULT=new MulOp_ModulateEqual(); :};

		  



